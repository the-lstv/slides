<head>
    @use(ls:5.2.8[flat, tabs]);
    @use(google-fonts["JetBrains Mono"]);

    @page font: "JetBrains Mono";
</head>

<body ls ls-style="flat" ls-theme="dark" .level-0 state="loading">
    <script>
        class Presentation extends LS.EventEmitter {
            constructor(options) {
                super();

                this.container = LS.Create();
                this.viewport = LS.Create().addTo(this.container);
                this.content = LS.Create().addTo(this.viewport);

                this.container.classList.add("presentation-container");
                this.content.classList.add("presentation-content");
                this.content.classList.add("level-0");
                this.viewport.classList.add("presentation-viewport");

                this.tabs = new LS.Tabs(this.content, {
                    list: false,
                    styled: false
                });

                this.options = LS.Util.defaults({
                    resolution: [1920, 1080],
                    globalEvents: true,
                    hasTransitions: true,
                    loop: false // If true, it'l loop around infinitely
                }, options);

                // Resize observer
                this.resizeObserver = new ResizeObserver(() => {
                    this.applyResolution();
                });
        
                this.resizeObserver.observe(this.content);

                window.addEventListener("resize", () => {
                    this.applyResolution();
                });

                document.addEventListener("fullscreenchange", () => {
                    this.applyResolution();
                });

                this.setResolution();

                let initial = true, lastIndex = -1;
                this.tabs.on("changed", (newTabId, oldTabId) => {
                    const newTab = this.tabs.tabs.get(newTabId);
                    const oldTab = this.tabs.tabs.get(oldTabId);

                    const index = this.index;
                    const oldIndex = lastIndex;
                    const direction = lastIndex < index ? 1 : -1;
                    lastIndex = index;

                    this.cancelAnimations(); // Clear pending animations

                    if(oldTab && !this.options.hasTransitions) {
                        oldTab.element.style.display = "none";
                    }

                    newTab.element.style.display = "";
                    newTab.element.classList.remove("left");
                    for(const left of newTab.element.querySelectorAll(".left")) {
                        left.classList.remove("left");
                        left.style.display = "";
                    }

                    this.emit("changed", [newTab, oldTab, { initial, direction, index, oldIndex }]);
                    initial = false;
                });

                this.evh = this.handleEvent.bind(this);
                if(this.options.globalEvents) {
                    window.addEventListener("keydown", this.evh);
                    window.addEventListener("wheel", this.evh);
                }

                this.container.addEventListener("click", this.evh);
            }
            
            static SPRING = 'linear(0, 0.0018, 0.007 1.17%, 0.0334, 0.0758, 0.1306 5.54%, 0.2505 8.16%, 0.6477 16.03%, 0.7622 18.65%, 0.8498, 0.9229 23.32%, 0.9878 25.94%, 1.0308 28.27%, 1.0643 30.9%, 1.0791, 1.0886 34.39%, 1.094, 1.0944 38.48%, 1.0903 40.81%, 1.0814 43.43%, 1.0362 53.05%, 1.0184 57.42%, 1.0059, 0.9976 65.58%, 0.9925 70.25%, 0.991 75.79%, 0.9996 99.98%)';

            applyResolution() {
                const cw = window.innerWidth;
                const ch = window.innerHeight;

                const scale = Math.min(
                    (this.options.containerWidth || cw) / this.options.resolution[0],    
                    (this.options.containerHeight || ch) / this.options.resolution[1]
                );

                this.scale = scale;
                this.content.style.transform=`translate(-50%,-50%) scale(${scale})`;
            }

            setResolution(w, h) {
                this.options.resolution = [w || this.options.resolution[0], h || this.options.resolution[1]];
                this.content.style.width = this.options.resolution[0] + "px";
                this.content.style.height = this.options.resolution[1] + "px";
                this.applyResolution();
            }

            handleEvent(event) {
                switch(event.type) {
                    case "keydown":
                        switch(event.key) {
                            case "ArrowLeft":
                                this.tabs.previous(this.options.loop);
                                break;
                            case "ArrowRight": case " ":
                                this.tabs.next(this.options.loop);
                                break;
                            case "f":
                                this.toFullscreen();
                                break;
                        }
                        break;

                    case "wheel":
                        break;

                    case "click":
                        if(event.clientX < window.innerWidth / 2) {
                            this.tabs.previous(this.options.loop);
                        } else {
                            this.tabs.next(this.options.loop);
                        }
                        break;

                    // Add more cases as needed
                }
            }

            toFullscreen() {
                const fsTarget = this.container;
                if (fsTarget.requestFullscreen) {
                    fsTarget.requestFullscreen();
                } else if (fsTarget.mozRequestFullScreen) { /* Firefox */
                    fsTarget.mozRequestFullScreen();
                } else if (fsTarget.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    fsTarget.webkitRequestFullscreen();
                } else if (fsTarget.msRequestFullscreen) { /* IE/Edge */
                    fsTarget.msRequestFullscreen();
                }
            }

            add(container) {
                const id = container.id || "slide-" + this.tabs.tabs.size + LS.Misc.uid();
                this.tabs.add(id, container);

                container.style.display = "none";

                if(this.tabs.index === -1) {
                    this.set(0);
                }
            }

            /**
             * Go to a specific slide.
             * @param {string|number} id - The ID or index of the slide to go to.
             */
            set(id) {
                this.tabs.set(id);
            }

            /**
             * Sorts the slides based on the provided compare function.
             * @param {Function} compareFunction - The function used to determine the order of the slides.
            */
            sort(compareFunction) {
                this.tabs.order.sort(compareFunction);
            }

            get index() {
                return this.tabs.index;
            }

            #animations = [];

            /**
             * Helper for animations.
            */
            animate(target, keyframes, options) {
                if(!target) return;

                if(typeof target === "string" || Array.isArray(target)) {
                    const array = Array.isArray(target)? target: presentation.tabs.currentElement()?.querySelectorAll(target);
                    if(array && array.length) {
                        let i = 0;
                        for(let foundTarget of array) {
                            const newOptions = Object.assign({}, options);
                            if(newOptions.staggering) {
                                newOptions.delay = (newOptions.delay || 0) + (newOptions.staggering * i);
                                delete newOptions.staggering;
                            }
                            this.animate(foundTarget, keyframes, newOptions);
                            i++;
                        }
                    }
                    return;
                }

                const animation = target.animate(keyframes, options);
                this.#animations.push(animation);
                return animation;
            }

            /**
             * Helper for leaving animations (hide element on end).
            */
            leaving(target, keyframes, options) {
                const animation = this.animate(target, keyframes, options);
                animation.isLeaving = true;

                animation.onfinish = () => {
                    if(this.#animations.includes(animation)) {
                        // this.animations.splice(this.animations.indexOf(animation), 1);
                        animation.effect.target.style.display = "none";
                        animation.effect.target.classList.add("left");
                    }
                };
            }

            cancelAnimations() {
                for(const animation of this.#animations) {
                    if(animation.isLeaving) {
                        animation.effect.target.style.display = "none";
                        animation.effect.target.classList.add("left");
                    }

                    animation.cancel();
                }

                this.#animations.length = 0;
            }

            // Helper to split letters on an element
            static splitLetters(target, className = "") {
                const letters = target.textContent.split("");
                target.textContent = "";
                for(const letter of letters) {
                    const span = document.createElement("span");
                    span.textContent = letter;
                    if(className) {
                        span.classList.add(className);
                    }
                    target.appendChild(span);
                }
            }

            destroy() {
                this.resizeObserver.disconnect();
                this.container.remove();
                this.cancelAnimations();
                this.container = null;
                this.tabs.destroy();
                this.tabs = null;
                this.resizeObserver = null;
                this.destroyed = true;

                window.removeEventListener("keydown", this.evh);
                window.removeEventListener("wheel", this.evh);
                this.container.removeEventListener("click", this.evh);

                // TODO: destroy event handlers & stuff
            }
        }

        window.Presentation = Presentation;
        window.initialized = false;

        // We give the presentation a chance to register the presentation itself
        window.init = function (options) {
            window.initialized = true;
            window.presentation = new Presentation(options || window.PRESENTATION_META || {});
            return window.presentation;
        }
    </script>

    <div #initial-slides hidden>
        <!-- Slide content will go here -->
        <template::content />
    </div>

    <script>
        if(!window.initialized) {
            // Initialize by default
            window.presentation = new Presentation(window.PRESENTATION_META || {});
        }

        // We assume it was initialized before.
        window.initialized = true;

        // We add slides from the static content; but it can also be done programatically.
        for(const slide of document.querySelectorAll("#initial-slides > div")) {
            presentation.add(slide);
        }

        // Slide order is kept by presentation.tabs.order (array of slide IDs).
        // You can simply sort that array in whatever way you want to change the slide order.

        window.addEventListener("DOMContentLoaded", () => {
            document.body.append(presentation.container);
            document.body.removeAttribute("state");
            presentation.quickEmit("ready");
        });
    </script>

    <style>
        .presentation-container {
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        .presentation-viewport {
            transform: translate(50%, 50%);
            height: 100%;
            width: 100%;
        }
        
        .presentation-content {
            position: relative;

            /* Slide */
            .ls-tab-content {
                position: absolute;
                overflow: hidden;
                height: 100%;
                width: 100%;
                inset: 0;
            }

            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;

            img { pointer-events: none; }
        }

        body, html {
            height: 100vh;
            width: 100vw;
            margin: 0;
            overflow: hidden !important;
            background-color: #000 !important;
        }
    </style>
</body>